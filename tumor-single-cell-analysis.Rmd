---
title: "Single cell RNAseq analysis of B16 tumor infiltrating immune cells"
output:
  html_document:
    toc: true
    toc_float: true
---

## Introduction

Here, I provide a step by step analysis of the publicly available single cell RNA-sequencing dataset from Ishizuka et al. 2019, using the R package ```Seurat```. This single cell RNA-sequencing dataset was generated using the 10X Genomics platform, and was derived from tumor-infiltrating leukocytes isolated from mouse B16 tumors.

The publication can be found at: https://www.ncbi.nlm.nih.gov/pubmed/30559380. The data can be downloaded from: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110746. This data consists of a set of matrices which dictate the cellular barcode, gene name, and expression values for each cell (barcodes.tsv.gz, genes.tsv.gz, and matrix.mtx.gz). These matricies are the standardized output provided by the 10X Genomics software Cell Ranger after processing the raw fastq files.

This analysis is meant to serve as an example of how to analyze single cell RNA-sequencing data generated using the 10X Genomics platform using the R package ```Seurat```. I provide details for each step so that researchers with only basic knowledge of R will be able to analyze a single cell RNA-seq experiment. I hope that this will help researchers who are planning to perform their own single-cell RNA-sequencing experiment have an easier time making sense of their data.

## Load packages

```{r message=F}
library(Seurat)
library(future)
library(tidyverse)
options(future.globals.maxSize= 6815744000)
```

This analysis was performed using ```Seurat``` version 3.0.2. I also use the ```future``` package in order to speed things up, as some of the processing steps take a long time. The ```tidyverse``` package provides a nice set of tools for both data wrangling and visualization.

## Read in the data and create the Seurat object

The ```Read10X``` function is used to read in the data matricies. If you run into issues with this step, check whether your files are named correctly. For this analysis, I had to remove the GSE identifier (e.g. change GSE110746_barcodes.tsv to barcodes.tsv, and so on). I placed the three data files into a directory named "haining", and specified this directory for the data.dir parameter. If you are getting data from a Cell Ranger pipeline, you can find them in the outs/filtered_feature_bc_matrix folder.

```{r}
# Read in data
raw_data <- Read10X(data.dir = "haining")
```

Once the raw data is read in, you can create a Seurat object using ```CreateSeuratObject```.

```{r}
b16 <- CreateSeuratObject(counts = raw_data, min.cells = 3, min.features = 200, project = "b16", names.delim = "-", names.field = 2)
```

If your data was produced from a single sample, you won't have to use the names.delim or names.field parameters. In this case, the immune infiltrate from 2 ADAR1 KO tumors and 2 control tumors (4 10X samples total) were aggregated using Cell Ranger aggr, resulting in the barcodes having the identifiers that look like: AAACCTGTCACATGCA-ADAR_S1. We can pull out the original identifier of "ADAR_S1" by specifying ```names.delim = "-"``` and ```names.field = 2```.

We can see if this worked correctly by examining the meta.data portion of the Seurat object below, seeing if sample names such as "ADAR_S1" show up in the ```orig.ident``` column. Here, a cell is represented by its barcode value, and its attributes can be found as a rowname in ```b16@meta.data```. You can find the raw expression value for each gene in the transcriptome as a column in ```b16@assays$RNA@data```.

```{r}
head(b16@meta.data)
```

A quick glance at the unique values in ```orig.ident``` shows the 4 biological samples that were aggregated:

```{r}
unique(b16@meta.data$orig.ident)
```

You can also check the attributes of this object by simply calling its name:

```{r}
b16
```

Each gene is considered a "feature", and each cell is considered a "sample".

## Measure mitochondrial and ribosomal content and filter cells

We can add columns to the meta.data by using ```[[ ]]```. Below, we use regexes to pull out mitochondrial or ribosomal genes, and then assign the proportion of transcripts they represent for each cell using the PercentageFeatureSet function. It's always a good idea to first check that your regex is pulling out the right genes:

```{r eval=F}
# check whether you are getting the genes you want
grep("^mt-", rownames(b16@assays$RNA@data), value = T)
grep("Rps|Rpl|Mrpl|Mrps", rownames(b16@assays$RNA@data), value = T)
```

```{r}
# add the percentage of these mitochondrial or ribosomal genes to the meta.data
b16[["percent.mito"]] <- PercentageFeatureSet(object = b16, pattern = "^mt-")
b16[["percent.ribo"]] <- PercentageFeatureSet(object = b16, pattern = "Rps|Rpl|Mrpl|Mrps")

plot1 <- FeatureScatter(object = b16, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(object = b16, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot3 <- FeatureScatter(object = b16, feature1 = "nCount_RNA", feature2 = "percent.ribo")

CombinePlots(plots = list(plot1, plot2, plot3))
```

We observe that there are some cells in each treatment condition that have high levels of mitochondrial and ribosomal gene expression. We choose to filter out these cells, because they are likely to be dead or dying.

```{r}
b16 <- subset(x = b16, subset = nFeature_RNA > 200 & nFeature_RNA < 8000 & percent.mito < 25 & percent.ribo < 40 )
```

I chose a threshold of 25% for mitochondrial genes and This threshold is just an approximation, and in some cases may not filter out all the truly dead/dying cells. If there are remaining dead/dying cells, they will often form their own subcluster, and can be removed using the later on using the subset() function. We can observe how many cells were filtered out by simply calling the object name and comparing with the output above.

```{r}
b16
```

We observe that there are 8755 cells remaining, down from the original 8834.

## Data normalization and cell clustering

Now that we have created the Seurat object and performed some initial filtering of dead cells, we can move onto data normalization, clustering, and cell identification. These are all performed using built-in functions within the Seurat R package, which are executed sequentially to process the object. Seurat objects are large and consume a lot of memory, so usually I continue to overwrite the same object at each step. The ```ScaleData``` function typically takes a lot of computing power and a long time to run, so here I use the future package to speed things up with multi-core processing. Essentially, these steps log-transform the expression values and scale each cell based its total read count (UMI) and mitochondrial / ribosomal percentage.

```{r eval=F}
b16 <- NormalizeData(b16, normalization.method = "LogNormalize", scale.factor = 10000)
b16 <- FindVariableFeatures(b16, selection.method = "vst", nfeatures = 2000)
all.genes <- rownames(b16)
plan("multiprocess", workers = 10)
b16 <- ScaleData(b16, features = all.genes, vars.to.regress = c("nCount_RNA", "percent.mito", "percent.ribo"))
plan("multiprocess", workers = 1)
```

```{r include = F}
# in order to speed up knitting the R notebook, I pre-load the processed object here
load("b16_all_v3.Robj")
```

Once the values have been normalized and scaled, we can begin to cluster each cell based on their gene expression patterns. Our goal is that cells that express similar patterns of genes (high gene "X", low gene "Y", etc.) will cluster together. To do this, we use the ```RunPCA``` function.

```{r}
b16 <- RunPCA (b16, features = VariableFeatures(object = b16), ndims.print = 1:2)
ElbowPlot(object = b16, ndims = 50)
```

We have the liberty of determining the number of PCs to choose for downstream clustering functions. Seurat uses graph-based cluster identification, and a common way of visualizing the clustering pattern is through t-distributed stochastic neighbor embedding (tSNE). Both of these steps require us to imput the number of PCs to use.

Here, I visually inspect the scree plot to determine how many PCs to choose, usually selecting a number at which the standard deviation "flattens" out, after which adding more PCs only mimimally reduces standard deviation. Here, I will choose 40 PCs. A more systematic way of choosing the PCs can be implemented, but from my experience, choosing PCs within 10% of this range has not impacted cluster identification. After choosing the number of PCs to use, we can run the clustering functions below:

```{r include = F}
# in order to speed up knitting the R notebook, I pre-load the processed object here
load("b16_all_v3.Robj")
```

```{r eval=F}
b16 <- FindNeighbors(b16, dims = 1:40)
b16 <- FindClusters(b16, resolution = c(0.2, 0.4, 0.6))
b16 <- RunTSNE(b16, dims = 1:40)
```

The resolution parameter for the ```FindClusters``` function is what you have to pay the most attention to. A higher resolution value will result in a larger number of clusters being identified, and vice versa. It dictates how over- or under- clustered your cells will be. Often times, you will have to try a bunch of different resolution values, examine how your cells cluster in each scenario, and determine which makes the most biological sense. You should ask yourself questions such as: do I observe cell clusters that are biologically distinct being aggregated with each other (e.g. NK cells and T cells being combined in the same cluster)? If so, your resolution is too low and should be higher. In contrast, if you observe multiple clusters of what appears to be the same cell type, you might have chosen too high of a resolution. That being said, single cell RNA-sequencing is great at detecting novel sub-populations of cells and revealing heterogeneity within what we previously may have thought to have been a single cell type. It is important to invest time into determining whether you are observing true biological heterogeneity vs. an artefact of choosing too high of a resolution. In my opinion, it is safer to choose a lower resolution to begin with, and then sub-cluster individual clusters of interest to determine whether there is any further heterogeneity that is biologically relevant. I will show an example of this later on in the analysis.

Here, we pass a vector of resolution values ranging from 0.2 to 0.6 to ```FindClusters```. We observe that the cluster attributions are defined as columns in ```b16@meta.data```. The field ```b16@active.ident``` houses the cluster definitions for the "right-most" resolution of 0.6.

```{r}
head(b16@meta.data)
```

Now that clusters have been assigned, we can visualize the clustering patterns using the built-in Seurat function, ```DimPlot```, using the t-SNE dimentionality reduction option. The visualization functions within Seurat will utilize the clustering information from ```active.ident``` by default, unless the ```group.by``` parameter is specified. Below, I plot the t-SNE plot for each resolution. You can also swap the active.ident with any of the columns in the meta.data using the function SetIdent.

```{r}
DimPlot(b16, label = T, reduction = "tsne", group.by = "RNA_snn_res.0.2")
DimPlot(b16, label = T, reduction = "tsne", group.by = "RNA_snn_res.0.4")
DimPlot(b16, label = T, reduction = "tsne", group.by = "RNA_snn_res.0.6")
```

We observe that as the resolution factor increases, more clusters are shown, and that the biggest jump in the number of clusters occurs between resolution 0.2 and resolution 0.4. Often times, rare clusters with small numbers of cells will appear at higher resolutions. These rare clusters may have biological significance, and should be separated from other cell types when possible. For example, cluster 1 in resolution 0.2 appears to be a T cell cluster, but further separates into two clusters at a resolution of 0.4: a large cluster of CD8+ T cells (cluster 2, resolution 0.4) and a much smaller but distinct population of T-regulatory cells (cluster 11, resolution 0.4). I can make this judgement by examining the expression patterns of the genes CD8a, which defines CD8+ T cells, and Foxp3, which defines T-regulatory cells using a FeaturePlot (expression of a gene overlaid on top of a t-SNE plot):

```{r}
FeaturePlot(b16, c("Cd8a", "Foxp3"))
```

T-regulatory cells have vastly different functional properties compared to cytotoxic CD8+ T cells, and should definitely be given their own cluster definition. Based on this observation, I would determine 0.2 as too "low" of a resolution and choose either 0.4 or 0.6. Resolution 0.4 and 0.6 look very similar, except that cluster 6 from resolution 0.4 splits into clusters 6 and 11 in resolution 0.6. I will choose resolution 0.6 to work with for the rest of the analysis.

## Identify cell types based on marker expression

Aside from examining gene expression patterns using ```FeaturePlot```, a more in-depth way of identifying the cell types corresponding to each cluster can be performed by finding cluster-specific genes using the function ```FindAllMarkers```. This function will return the genes that are most highly upregulated in each cluster compared to all other clusters. We can then read through the top 30 genes for each cluster and use these genes to judge what cell type they define.

```{r eval=F}
# determine cell type-specific markers using FindAllMarkers
plan("multiprocess", workers = 10)
b16.markers <- FindAllMarkers(b16, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
plan("multiprocess", workers = 1)

# save this to file if you want to come back to them
# save(b16.markers, file = "b16_all_markers_res06_v3.Robj")
```

```{r include=F}
# in order to speed up knitting the R notebook, I pre-load the processed object here
load("b16_all_markers_res06_v3.Robj")
```

```{r}
b16.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
```

Sifting through this table, we can assign cell types to each of the clusters. For example, cluster 1 is defined by high Ly6c2, Plac8, and Ccr2 expression which are all canonical monocyte markers, so it is likely that these represent monocytes. Similarly, cluster 2 has high Cd8a, Cd8b1, and Gzmb expression, suggesting that these cells are CD8+ cytotoxic T cells. I use this same thought process to identify each of the clusters in the dataset, and then store these designations in the variable ```new.cluster.ids``` below. I can use ```RenameIdents``` to rename the clusters and then display the labels on top of each cluster on the t-SNE plot.

```{r}
# res 0.6 cluster labels
new.cluster.ids <- c("0- C1Q-hi TAM",
                     "1- Monocyte",
                     "2- CD8 T cell",
                     "3- Arg1-hi TAM",
                     "4- Melanocyte",
                     "5- Folr2-hi TAM",
                     "6- cDC2",
                     "7- Melanocyte",
                     "8- cDC1",
                     "9- Migratory DC",
                     "10- NK",
                     "11- MHCII-hi TAM",
                     "12- Treg",
                     "13- Melanocyte",
                     "14- Fibroblast",
                     "15- pDC",
                     "16- Hemophagocyte TAM"
                     )

b16.labeled <- b16
names(new.cluster.ids) <- levels(b16.labeled)
b16.labeled <- RenameIdents(b16.labeled, new.cluster.ids)

DimPlot(b16.labeled, label = T, reduction = "tsne")
```

As expected, most of the cell types that come from similar origins cluster closely with one another. The different types of tumor associated macrophages (TAMs) seem to cluster near each other, likewise for the different types of dendritic cells. 

## Subsetting, reclustering, and aggregating

Since we are interested in the tumor immune infiltrate, it makes sense to remove all the non-immune cells in the dataset. According to the materials and methods section of the manuscript, B16 tumor cells were spiked in to the sample, which likely corresponds to the melanocyte clusters we defined above. We also observe a small population of fibroblasts (cluster 14) that can also be removed. We can double-check that these cells are non-immune cells by checking for Ptprc (CD45) expression.

```{r}
FeaturePlot(b16.labeled, "Ptprc")
VlnPlot(b16.labeled, "Ptprc")
```

We observe that clusters 4, 7, 13, and 14 indeed have low CD45 expression. We can remove these cells using the ```subset``` function. Although cluster 16 also has low CD45 expression, the genes that define this cluster very closely resemble a novel macrophage population called hemophagocytes (Akilesh et al. 2019), which in my opinion qualifies it for inclusion as an "immune cell" despite its low CD45 expression.

```{r}
# remove non-immune cell clusters 4, 7, 13, 14
# since the cluster numbers start at 0 instead of 1, have to indicies by 1 in order to subtract the clusters from vector
b16 <- subset(b16, idents = c(0:16)[-c(5,8,14,15)])
DimPlot(b16, label = T, reduction = "tsne")
```

After removing the non-immune cells, we re-run the normalization, scaling, and clustering functions.

```{r eval = F}
# re-normalize and scale the object after removing the non-CD45+ clusters
b16 <- NormalizeData(b16, normalization.method = "LogNormalize", scale.factor = 10000)
b16 <- FindVariableFeatures(b16, selection.method = "vst", nfeatures = 2000)
all.genes <- rownames(b16)
plan("multiprocess", workers = 10)
b16 <- ScaleData(b16, features = all.genes, vars.to.regress = c("nCount_RNA", "percent.mito", "percent.ribo"))
plan("multiprocess", workers = 1)
b16 <- RunPCA (b16, features = VariableFeatures(object = b16))
b16 <- FindNeighbors(b16, dims = 1:40)
b16 <- FindClusters(b16, resolution = c(0.6))
b16 <- RunTSNE(b16, dims = 1:40)
```

```{r include = F}
# in order to speed up knitting the R notebook, I pre-load the processed object here
load("b16_immune_v3.Robj")
```

```{r}
DimPlot(b16, label = T, reduction = "tsne")
```

Aftwerwards, we can identify the cell types in the filtered, re-clustered object just as we did before, by first finding the cluster-specific markers using ```FindAllMarkers``` and then using these markers to assign cell types.

```{r eval=F}
plan("multiprocess", workers = 10)
b16.markers <- FindAllMarkers(b16, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
plan("multiprocess", workers = 1)
```

```{r include=F}
# in order to speed up knitting the R notebook, I pre-load the processed object here
load("b16_markers_res06_immune_v3.Robj")
```

```{r}
b16.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
```

```{r}

new.cluster.ids <- c("0- Activated Monocyte",
                     "1- C1Q-hi TAM",
                     "2- Arg1-hi TAM",
                     "3- CD8 T cell",
                     "4- Folr2-hi TAM",
                     "5- cDC2",
                     "6- Classical Monocyte",
                     "7- Treg",
                     "8- cDC1",
                     "9- NK cell",
                     "10- MHCII-hi TAM",
                     "11- Migratory DC",
                     "12- pDC",
                     "13- Hemophagocyte TAM"
                     )
b16.labeled <- b16
names(new.cluster.ids) <- levels(b16.labeled)
b16.labeled <- RenameIdents(b16.labeled, new.cluster.ids)

DimPlot(b16.labeled, label = T, reduction = "tsne")
```

We observe a similar set of cell types as before, except that the monocytes have now split up into two groups. Based on the gene expression that define each group, there appears to be an activated population (cluster 0) and an unactivated population (cluster 6).

The clusters are by default ordered by cell abundance, which makes looking at some of the visualizations complicated. It makes more intuitive sense to lump each cell type together (all monocytes together, all tams together, etc). You can reorder the clusters by manually specifying the order in the levels parameter of ```factor()```:

```{r}
# reorder by cell type:
reordered.new.cluster.ids <- c("0- Activated Monocyte",
                               "6- Classical Monocyte",
                               "1- C1Q-hi TAM",
                               "2- Arg1-hi TAM",
                               "4- Folr2-hi TAM",
                               "10- MHCII-hi TAM",
                               "13- Hemophagocyte TAM",
                               "8- cDC1",
                               "5- cDC2",
                               "11- Migratory DC",
                               "12- pDC",
                               "3- CD8 T cell",
                               "7- Treg",
                               "9- NK cell"
                              )

b16.labeled@active.ident <- factor (b16.labeled@active.ident, levels = reordered.new.cluster.ids)

DimPlot(b16.labeled, label = T, reduction = "tsne")
VlnPlot(b16.labeled, "Cd40")


plot_proportions <- function (seuratobj){
  proportions <- table(seuratobj@active.ident)/length(seuratobj@active.ident)*100
  proportions <- as.data.frame(proportions)
  ggplot(proportions , aes (x = Var1, y = Freq))+
    geom_bar(stat = "identity", aes(fill = Var1))+
    theme_classic()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1))+
    labs (x = NULL, y = "Percent of total cells", title = "Cell abundance by cluster")+
    theme(axis.text.x = element_text(size = 12, color = "black"), axis.text.y = element_text(size = 12, color = "black"))+
    NoLegend()
}

plot_proportions(b16.labeled)

```

If desired, clusters can be combined by naming them with the exact same names and using ```RenameIdents```. This type of aggregation can be performed when you wish to lump common cell types together. It is useful when you want to gain a high-level overview of the cellular composition of the dataset.

```{r}
combined.cluster.ids <- c("Monocyte",
                     "TAM",
                     "TAM",
                     "CD8",
                     "TAM",
                     "cDC2",
                     "Monocyte",
                     "Treg",
                     "cDC1",
                     "NK",
                     "TAM",
                     "Migratory DC",
                     "pDC",
                     "TAM"
                     )
b16.combined <- b16
names(combined.cluster.ids) <- levels(b16.combined)
b16.combined <- RenameIdents(b16.combined, combined.cluster.ids)

# reorder the clusters based on myeloid and lymphoid
b16.combined@active.ident <- factor(b16.combined@active.ident, levels = c("TAM", "Monocyte", "cDC1", "cDC2", "pDC", "Migratory DC", "CD8", "Treg", "NK"))
```

Using this method, these combined cluster designations are stored in the active.ident portion of the seurat object. The functions in Seurat will by default access ```active.ident```, so they all still work as expected:

```{r}
DimPlot(b16.combined, label = T, reduction = "tsne")
plot_proportions(b16.combined)
```

```{r eval=F}
plan("multiprocess", workers = 10)
b16.markers <- FindAllMarkers(b16.combined, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
plan("multiprocess", workers = 1)
```

```{r include=F}
# in order to speed up knitting the R notebook, I pre-load the processed object here
load("b16_markers_aggregated_v3.Robj")
```

```{r}
b16.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
```

## Visualizations

At this point, we can start performing some visualizations in order to gain insight from the data. We can start to answer questions such as:

*which cell types express gene X?
*what percent of each cell type is represented in the dataset?
*how do the percentages change in the WT tumors compared to the KO tumors?

I will first showcase the basic built-in visualizations that come with the Seurat package. Then, I go more in-depth into various types of visualizations and data mining that can be performed on this processed Seurat object. For the purposes of this demonstration, I will be using the version of the Seurat object in which I've aggregated the clusters by cell type.

### Built-in Seurat Visualizations

#### 1. FeaturePlot

The ```FeaturePlot``` is one of the most useful functions for determining gene expression patterns in your dataset. This, used in conjunction with the t-SNE plot, can be used side-by-side to visually assess which cell types express a given gene.

```{r fig.width=10, fig.height=5}
fp <- FeaturePlot(b16.combined, "Ccr2", pt.size = 0.8)+NoLegend()
tp <- DimPlot(b16.combined, pt.size = 0.8, label = T, reduction = "tsne")+NoLegend()
CombinePlots(plots = list(tp,fp))
```

In the example above, we observe that the chemokine receptor Ccr2 is expressed by cells in the monocyte cluster, as expected based on the literature. The beauty of single cell RNA-seq is that we can also assess the expression of this receptor in all the other cell types as well. Visually, we can observe that Tregs, NK cells, and cDC2 also express Ccr2 to a high degree. Furthermore, you can plot two genes on top of the same plot by setting ```blend = T```. This allows for some interesting comparisons to be made between pairs of genes that may have biological significance.

```{r fig.width=12,fig.height =3}
FeaturePlot(b16.combined, c("Ccl2", "Ccr2"), blend = T)
```

In this case, I plot Ccr2 with its ligand, Ccl2. This gives me insight into which cells express the ligand for Ccl2, and which cells have its receptor, Ccr2. It is likely that Ccr2+ cells (monocytes, Tregs, etc.) will migrate into proximity with Ccl2+ cells (Tumor associated macrophages).

#### 2. VlnPlot

The FeaturePlots above are nice to make a visually compelling argument, but it is necessary to quantitate the amount of signal observed in each cluster. To do this, we can use the built-in function ```VlnPlot```, which will display the expression of a given gene in each of the clusters in ```active.ident```.

```{r}
VlnPlot(b16.combined, "Ccr2", pt.size =0.1)
```

The width of the violin plot is a measure of the proportion of cells at the corresponding expression level. We observe that the monocyte cluster expresses the highest level of Ccr2.

#### 3. RidgePlot

An alternative to the ```VlnPlot``` is the ```RidgePlot```, which you can think of as flippin the violin plot on its side. This provides a density histogram that displays the magnitude and proportion of cells that express the gene for each cluster. Those who are used to looking at flow cytometry histograms may enjoy this type of plot more.

```{r}
RidgePlot(b16.combined, "Ccr2")
```

#### 4. DotPlot

If you wish to compare the expression of several genes at the same time across all clusters, the ```DotPlot``` is a very useful way of doing so. The size of the dots in the plot correspond do the percentage of cells within the cluster that are positive for expression (have an expression value > 0). The color of the dot represents the magnitude of expression of the cells that are positive (i.e. do they express high levels, or low levels of the gene relative to other clusters?).

```{r}
cluster_specific_genes <- c("C1qa", "Apoe","Ly6c2", "Ccr2", "Xcr1", "Clec9a", "Cd209a", "Clec4a4", "Siglech", "Ccr9", "Ccr7", "Fscn1", "Cd8a", "Cd3e", "Foxp3", "Il2ra", "Ncr1", "Klra4")

# can feed in an RColorBrewer pallete, I chose RdBu here, also adjusted the x-axis labels to match tick marks
DotPlot(b16.combined, features = rev(cluster_specific_genes), cols = "RdBu", plot.legend = T)+
  theme(axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 1))
```

Here, I chose to plot some genes that are described in the literature to be specific to each cell type defined in our dataset. We observe that most of the genes are indeed specifically expressed by their cell types, with the exception of Ly6c2, which we observe to be expressed at the highest level in pDCs rather than monocytes.

We can also use the dot plot to make knockout vs wildtype comparisons in this dataset. In the example below, I can subset on a specific group (in this case, CD8 T cells) and then assess the activation / exhaustion level in CD8 T cells from the KO vs WT samples using a DotPlot. These genes were obtained from Carmona et al. 2019 (https://www.biorxiv.org/content/10.1101/800847v1).

```{r}
# subset just the CD8 cluster
cd8 <- subset(b16.combined, idents = "CD8")

# set the clustering identity back to the original sample origin, "orig.ident"
cd8 <- SetIdent(cd8, value = "orig.ident")

t_cell_genes <- c("Entpd1","Havcr2", "Tigit", "Lag3","Pdcd1", "Batf","Tox","Id2","Ccl3","Prf1", "Fasl", "Gzmb","Gzmk",  "Ifng", "Ccl5","Ly6c2", "Cd69",  "Cxcr3", "Cd44", "Tcf7", "Ccr7", "S1pr1", "Lef1", "Il7r", "Sell")

DotPlot(cd8, features = rev(t_cell_genes), cols = "RdBu", plot.legend = T)+
  theme(axis.text.x = element_text( angle = 90, vjust = 0.5, hjust = 1))
TSNEPlot(cd8)
```

We observe clear heterogeneity between the CD8 T cells isolated from each of the different samples. The genes between Entpd1 and Id2 represent T cell exhaustion genes, between Ccl3 and Cd69 represent T cell activation genes, and between Cxcr3 and Sell represent naive/memory T cell genes. Control_S3 and ADAR_S2 have a greater T cell activation signature compared to the other two samples, with higher levels of Gzmb, Ifng, Ccl5, and Ly6c2 expression. It does not appear that the activation signature correlates with the ADAR KO samples, since both the control and ADAR KO groups have a sample that displays this phenotype.

#### 5. Heatmap

A way to examine a large set of genes on a per-cell basis is by heatmap, using ```DoHeatmap```. Each column of the heatmap represents a single cell, organized by cluster. Each row of the heatmap represents a gene from the marker list you input, which typically is also organized by cluster. We can input the top set of markers from ```FindAllMarkers``` into Seurat's built-in heatmap function, ```DoHeatmap```. This results in a "diagonal" heatmap in which you can view how enriched each cluster-specific set of genes is for each cluster. You can also use this heatmap to visualize how your expression of your own genes of interest are spread across the clusters.

```{r}
top_b16_markers <- b16.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)

DoHeatmap(b16.combined, cells = WhichCells(b16.combined, downsample = 50, seed = 1), features = top_b16_markers$gene, size = 3.5, angle = 15, hjust =0)
```

We observe that a lot of "cluster-specific" genes from FindAllMarkers are actually expressed at varying levels by multiple cell types. For example, scanning from left to right for Irf8, which was determined to be a cDC1-specific gene, is enriched in both cDC1s as well as in pDCs and Migratory DCs. In contrast, a lot of the genes for pDCs appear to be exclusive to this cell type, in which almost no yellow signal is observed in any bin other than the pDC cluster.

### Self-made Visualizations

#### 1. Cell proportion plot

```{r}

```

#### 2. 


### Cosmetic changes

